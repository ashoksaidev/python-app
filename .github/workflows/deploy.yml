# CI/CD Workflow â€” Authored by Ashok Saidev (revised)
# Purpose: Securely deploy a Python service to Azure Web App (Docker Container)
# Uses Vault OIDC for secrets, JFrog Artifactory for images, Trivy for scanning

name: deploy-python-service

on:
  push:
    branches:
      - main
    paths:
      - 'src/**'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  VAULT_ADDR: ${{ secrets.VAULT_ADDR }}
  VAULT_NAMESPACE: ${{ secrets.VAULT_NAMESPACE }}
  HEALTHCHECK_URL: https://${{ secrets.AZURE_WEBAPP_NAME }}.azurewebsites.net/status
  IMAGE_NAME: python-service

jobs:
  deploy-artifact:
    runs-on: [self-hosted, Linux, X64] # Ensure these labels exactly match your self-hosted runner labels

    steps:
      - name: Checkout source code
        uses: actions/checkout@v4

      - name: Set up Python environment
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest

      - name: Run unit tests (fail on real test failures, allow graceful message if no tests)
        run: |
          pytest || RC=$?; \
          if [ "$RC" -eq 5 ]; then \
            echo "No tests were collected (pytest exit code 5). Continuing..."; \
          else \
            echo "pytest failed (exit code $RC)"; exit $RC; \
          fi

      - name: Authenticate with Vault (GitHub OIDC)
        id: vault
        uses: hashicorp/vault-action@v3
        with:
          url: ${{ secrets.VAULT_ADDR }}
          method: jwt
          path: jwt
          role: gh-actions
          jwtGithubAudience: https://github.com/${{ github.repository_owner }}
          namespace: ${{ secrets.VAULT_NAMESPACE }}
          exportEnv: true
          secrets: |
            ci/data/artifactory url          | ARTIFACTORY_URL;
            ci/data/artifactory repo_docker  | DOCKER_REPO;
            ci/data/artifactory username     | ARTIFACTORY_USER;
            ci/data/artifactory password     | ARTIFACTORY_PASSWORD

      - name: Docker login to JFrog
        run: echo "$ARTIFACTORY_PASSWORD" | docker login "$ARTIFACTORY_URL" -u "$ARTIFACTORY_USER" --password-stdin

      - name: Build Docker image
        run: docker build -t "$IMAGE_NAME:ci" .

      - name: Scan image with Trivy
        uses: aquasecurity/trivy-action@v1
        with:
          image-ref: "$IMAGE_NAME:ci"
          format: 'table'
          exit-code: '1' # fail the step on vulnerabilities (adjust or remove if you just want warnings)

      - name: Tag & push image to JFrog
        id: push_image
        run: |
          IMAGE_TAG="${ARTIFACTORY_URL}/${DOCKER_REPO}/${IMAGE_NAME}:$(git rev-parse --short HEAD)"
          docker tag "$IMAGE_NAME:ci" "$IMAGE_TAG"
          docker push "$IMAGE_TAG"
          # expose the image tag as a step output for later steps
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      # Authenticate to Azure using a service principal JSON stored in AZURE_CREDENTIALS secret
      # Required secret: AZURE_CREDENTIALS (JSON with clientId, clientSecret, subscriptionId, tenantId)
      # Required secret: AZURE_RESOURCE_GROUP (resource group where the Web App lives)
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Configure Web App container to use pushed image (and set registry credentials)
        env:
          IMAGE_TAG: ${{ steps.push_image.outputs.image_tag }}
        run: |
          az webapp config container set \
            --name "${{ secrets.AZURE_WEBAPP_NAME }}" \
            --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
            --docker-custom-image-name "$IMAGE_TAG" \
            --docker-registry-server-url "${ARTIFACTORY_URL}" \
            --docker-registry-server-user "${ARTIFACTORY_USER}" \
            --docker-registry-server-password "${ARTIFACTORY_PASSWORD}"

          # Restart the webapp to ensure it pulls the new image
          az webapp restart --name "${{ secrets.AZURE_WEBAPP_NAME }}" --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}"

      - name: Post-deployment health check
        run: |
          echo "Waiting for 10s to give the web app a moment to start..."
          sleep 10
          curl -f "$HEALTHCHECK_URL" || (echo "Health check failed" && exit 1)
