# Deploy workflow (CD) - corrected Vault usage & debug step
name: deploy-artifact

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Full image tag to deploy (ex: my-artifactory.example.com/repo/python-service:abcd123)'
        required: true
      deploy_target:
        description: 'Deployment target: kubernetes | azure_webapp | vm'
        required: true
        default: 'kubernetes'
      k8s_namespace:
        description: 'Kubernetes namespace (for kubernetes target)'
        required: false
        default: 'default'
      k8s_deployment:
        description: 'K8s Deployment name'
        required: false
      vm_host:
        description: 'VM host (for vm target)'
        required: false
      vm_user:
        description: 'VM user (for vm target)'
        required: false
      azure_resource_group:
        description: 'Azure resource group (for azure_webapp target)'
        required: false
      healthcheck_url:
        description: 'Optional healthcheck URL'
        required: false

permissions:
  id-token: write
  contents: read

env:
  VAULT_ADDR: ${{ secrets.VAULT_ADDR }}
  VAULT_NAMESPACE: ${{ secrets.VAULT_NAMESPACE }}
  IMAGE_INPUT: ${{ github.event.inputs.image_tag || '' }}

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Debug: check Vault reachability (temporary)
        run: |
          echo "Validating VAULT_ADDR secret presence and reachability (does not print the value)"
          if [ -z "${{ secrets.VAULT_ADDR }}" ]; then
            echo "VAULT_ADDR secret is not set in repository or org"; exit 1
          fi
          curl -fsS --connect-timeout 5 "${{ secrets.VAULT_ADDR }}/v1/sys/health" || (echo "Vault unreachable from runner"; exit 1)

      - name: Authenticate with Vault (GitHub OIDC)
        id: vault
        uses: hashicorp/vault-action@v3
        with:
          url: ${{ secrets.VAULT_ADDR }}
          method: jwt
          path: jwt
          role: gh-actions
          jwtGithubAudience: https://github.com/${{ github.repository_owner }}
          namespace: ${{ secrets.VAULT_NAMESPACE }}
          exportEnv: true
          secrets: |
            ci/data/artifactory url          | ARTIFACTORY_URL
            ci/data/artifactory repo_docker  | DOCKER_REPO
            ci/data/artifactory username     | ARTIFACTORY_USER
            ci/data/artifactory password     | ARTIFACTORY_PASSWORD

      - name: Ensure image tag is provided
        run: |
          if [ -z "${{ env.IMAGE_INPUT }}" ]; then
            echo "No image tag provided â€” supply via workflow_dispatch input 'image_tag'"; exit 1
          fi
          echo "image_to_deploy=${{ env.IMAGE_INPUT }}" >> $GITHUB_OUTPUT

      - name: Docker login to JFrog Artifactory
        run: |
          echo "$ARTIFACTORY_PASSWORD" | docker login "$ARTIFACTORY_URL" -u "$ARTIFACTORY_USER" --password-stdin

      - name: Pull image from Artifactory (verify existence)
        run: |
          IMAGE="${{ env.IMAGE_INPUT }}"
          if ! echo "$IMAGE" | grep -q '/'; then
            IMAGE="${ARTIFACTORY_URL}/${DOCKER_REPO}/${IMAGE}"
          fi
          echo "Attempting to docker pull $IMAGE"
          docker pull "$IMAGE"
          echo "pulled_image=$IMAGE" >> $GITHUB_OUTPUT

      - name: Deploy to Kubernetes - set image
        if: ${{ github.event.inputs.deploy_target == 'kubernetes' }}
        env:
          KUBECONFIG_CONTENT: ${{ secrets.KUBECONFIG }}
        run: |
          if [ -z "${{ github.event.inputs.k8s_deployment }}" ]; then
            echo "k8s_deployment must be provided for kubernetes target"; exit 1
          fi
          mkdir -p $HOME/.kube
          echo "$KUBECONFIG_CONTENT" > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          IMAGE="${{ env.IMAGE_INPUT }}"
          if ! echo "$IMAGE" | grep -q '/'; then
            IMAGE="${ARTIFACTORY_URL}/${DOCKER_REPO}/${IMAGE}"
          fi
          NAMESPACE="${{ github.event.inputs.k8s_namespace }}"
          DEPLOY="${{ github.event.inputs.k8s_deployment }}"
          kubectl set image deployment/"${DEPLOY}" "*=${IMAGE}" -n "${NAMESPACE}"
          kubectl rollout status deployment/"${DEPLOY}" -n "${NAMESPACE}" --timeout=120s

      - name: Azure login (if azure_webapp target)
        if: ${{ github.event.inputs.deploy_target == 'azure_webapp' }}
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Configure Web App container to use image (Azure)
        if: ${{ github.event.inputs.deploy_target == 'azure_webapp' }}
        env:
          IMAGE_TAG: ${{ github.event.inputs.image_tag }}
          AZURE_WEBAPP_NAME: ${{ secrets.AZURE_WEBAPP_NAME }}
          AZURE_RESOURCE_GROUP: ${{ github.event.inputs.azure_resource_group || secrets.AZURE_RESOURCE_GROUP }}
        run: |
          IMAGE="${IMAGE_TAG}"
          if ! echo "$IMAGE" | grep -q '/'; then
            IMAGE="${ARTIFACTORY_URL}/${DOCKER_REPO}/${IMAGE}"
          fi
          az webapp config container set \
            --name "$AZURE_WEBAPP_NAME" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --docker-custom-image-name "$IMAGE" \
            --docker-registry-server-url "$ARTIFACTORY_URL" \
            --docker-registry-server-user "$ARTIFACTORY_USER" \
            --docker-registry-server-password "$ARTIFACTORY_PASSWORD"
          az webapp restart --name "$AZURE_WEBAPP_NAME" --resource-group "$AZURE_RESOURCE_GROUP"

      - name: Deploy to VM via SSH (pull image & run)
        if: ${{ github.event.inputs.deploy_target == 'vm' }}
        env:
          VM_HOST: ${{ github.event.inputs.vm_host }}
          VM_USER: ${{ github.event.inputs.vm_user }}
        run: |
          if [ -z "$VM_HOST" ] || [ -z "$VM_USER" ]; then
            echo "vm_host and vm_user inputs are required for vm deploy target"; exit 1
          fi
          if [ -z "${{ secrets.VM_SSH_KEY }}" ]; then
            echo "Secret VM_SSH_KEY is required for VM deployment (private key)"; exit 1
          fi
          mkdir -p ~/.ssh
          echo "${{ secrets.VM_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          IMAGE="${{ github.event.inputs.image_tag }}"
          if ! echo "$IMAGE" | grep -q '/'; then
            IMAGE="${ARTIFACTORY_URL}/${DOCKER_REPO}/${IMAGE}"
          fi
          SSH="ssh -o StrictHostKeyChecking=no -i ~/.ssh/deploy_key ${VM_USER}@${VM_HOST}"
          $SSH "docker login ${ARTIFACTORY_URL} -u ${ARTIFACTORY_USER} -p '${ARTIFACTORY_PASSWORD}' && docker pull ${IMAGE} && docker stop app || true && docker rm app || true && docker run -d --name app -p 80:80 ${IMAGE}"

      - name: Optional healthcheck
        env:
          HEALTH: ${{ github.event.inputs.healthcheck_url || secrets.HEALTHCHECK_URL || '' }}
        run: |
          if [ -z "$HEALTH" ]; then
            echo "No healthcheck URL provided; skipping healthcheck." ; exit 0
          fi
          sleep 10
          curl -f "$HEALTH"
