name: build-and-deploy

on:
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  VAULT_ADDR: http://127.0.0.1:8212
  APP_NAME: python-app
  IMAGE_NAME: hello-world
  HEALTH_URL: http://localhost:8080/health

concurrency:
  group: pipeline-${{ github.ref }}
  cancel-in-progress: true

jobs:
  ci:
    name: ci • build & push
    runs-on: [self-hosted, Linux, X64]
    outputs:
      image_ref: ${{ steps.meta.outputs.image_ref }}
    steps:
      - uses: actions/checkout@v4

      - name: vault • read jfrog creds (oidc)
        uses: hashicorp/vault-action@v3
        with:
          url: ${{ env.VAULT_ADDR }}
          method: jwt
          role: gh-actions
          path: jwt
          exportEnv: true
          secrets: |
            ci/data/artifactory url          | ART_URL;
            ci/data/artifactory repo_docker  | ART_DOCKER_REPO;
            ci/data/artifactory username     | ART_USER;
            ci/data/artifactory password     | ART_PASS;

      - name: docker • login jfrog
        run: echo "$ART_PASS" | docker login "$ART_URL" -u "$ART_USER" --password-stdin

      - name: meta • compute tags
        id: meta
        run: |
          TAG_SHA="${{ github.sha }}"
          TAG_BRANCH="${GITHUB_REF##*/}"
          IMAGE_BASE="${ART_URL}/${ART_DOCKER_REPO}/${{ env.IMAGE_NAME }}"
          IMAGE_SHA="${IMAGE_BASE}:${TAG_SHA}"
          IMAGE_BRANCH="${IMAGE_BASE}:${TAG_BRANCH}"
          echo "IMAGE_SHA=$IMAGE_SHA" >> $GITHUB_ENV
          echo "IMAGE_BRANCH=$IMAGE_BRANCH" >> $GITHUB_ENV
          echo "image_ref=$IMAGE_SHA" >> $GITHUB_OUTPUT

      - name: docker • build
        run: |
          docker build -t "$IMAGE_SHA" .
          docker tag "$IMAGE_SHA" "$IMAGE_BRANCH"

      - name: inspect • image size & security
        run: |
          docker images "$IMAGE_SHA"
          docker scan "$IMAGE_SHA" || echo "Scan tool not available"

      - name: docker • push
        run: |
          docker push "$IMAGE_SHA"
          docker push "$IMAGE_BRANCH"

      - name: verify • image pushed to jfrog
        run: |
          curl -u "$ART_USER:$ART_PASS" "$ART_URL/api/docker/${ART_DOCKER_REPO}/v2/${{ env.IMAGE_NAME }}/tags/list" \
          | grep "${{ github.sha }}" || echo "Tag not found in JFrog"

  cd:
    name: cd • deploy
    runs-on: [self-hosted, Linux, X64]
    needs: ci
    steps:
      - name: vault • read jfrog creds (oidc)
        uses: hashicorp/vault-action@v3
        with:
          url: ${{ env.VAULT_ADDR }}
          method: jwt
          role: gh-actions
          path: jwt
          exportEnv: true
          secrets: |
            ci/data/artifactory url          | ART_URL;
            ci/data/artifactory repo_docker  | ART_DOCKER_REPO;
            ci/data/artifactory username     | ART_USER;
            ci/data/artifactory password     | ART_PASS;

      - name: docker • login jfrog
        run: echo "$ART_PASS" | docker login "$ART_URL" -u "$ART_USER" --password-stdin

      - name: deploy • pull & run locally
        env:
          IMAGE: ${{ needs.ci.outputs.image_ref }}
        run: |
          docker pull "$IMAGE"
          docker rm -f ${{ env.APP_NAME }} || true
          docker run -d --name ${{ env.APP_NAME }} -p 8080:8080 "$IMAGE"

      - name: verify • image pulled from jfrog
        run: docker inspect "$IMAGE" | grep RepoTags || echo "Image not found locally"

      - name: post-deploy • health
        run: |
          sleep 3
          curl -fsS "${{ env.HEALTH_URL }}"
          docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}"

      - name: deploy • to Kubernetes
        env:
          IMAGE: ${{ needs.ci.outputs.image_ref }}
        run: |
          kubectl set image deployment/python-app python-app=$IMAGE
          kubectl rollout status deployment/python-app

      - name: deploy • to staging VM
        env:
          IMAGE: ${{ needs.ci.outputs.image_ref }}
        run: |
          ssh user@staging-vm "docker pull $IMAGE && docker run -d -p 8080:8080 $IMAGE"

      - name: deploy • to Azure Web App
        uses: azure/webapps-deploy@v2
        with:
          app-name: python-app-staging
          images: ${{ needs.ci.outputs.image_ref }}
