# ------------------------------------------------------------
# CI/CD Workflow â€” Authored by Ashok Saidev
# Purpose: Securely deploy a Python service to Azure Web App
# This workflow uses:
# - Vault OIDC for secrets management
# - JFrog Artifactory for storing Docker images
# - Trivy for scanning vulnerabilities
# ------------------------------------------------------------

# Name of the workflow (visible in GitHub Actions UI)
name: deploy-python-service

# Trigger conditions for running this workflow
on:
  push:
    branches:
      - main                      # Run only when code is pushed to 'main' branch
    paths:
      - 'src/**'                  # Run only if files in 'src/' change
      - '.github/workflows/deploy.yml'  # Or if this workflow file itself changes
  workflow_dispatch:              # Allow manual trigger from GitHub UI

# Permissions required for GitHub Actions to access secrets and tokens
permissions:
  id-token: write                 # Needed for OIDC authentication with Vault
  contents: read                  # Allows reading repository contents

# Environment variables used throughout the workflow
env:
  VAULT_ADDR: ${{ secrets.VAULT_ADDR }}                       # Vault server address
  VAULT_NAMESPACE: ${{ secrets.VAULT_NAMESPACE }}             # Vault namespace
  HEALTHCHECK_URL: https://${{ secrets.AZURE_WEBAPP_NAME }}.azurewebsites.net/status  # Health check endpoint
  IMAGE_NAME: python-service                                  # Docker image name

# Define the job that runs the deployment steps
jobs:
  deploy-artifact:
    runs-on: [self-hosted, Linux, X64]  # Use a self-hosted Linux runner

    steps:
      # Step 1: Checkout the latest source code
      - name: Checkout source code
        uses: actions/checkout@v4

      # Step 2: Set up Python 3.10 environment
      - name: Set up Python environment
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      # Step 3: Install required Python packages
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest

      # Step 4: Run unit tests (non-blocking if no tests found)
      - name: Run unit tests
        run: |
          pytest || echo "No tests found"

      # Step 5: Decode GitHub OIDC token (for Vault authentication)
      - name: Decode GitHub OIDC token
        run: |
          TOKEN_URL="${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=https://github.com/${{ github.repository_owner }}"
          IDTOKEN="$(curl -s -H "Authorization: bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" "$TOKEN_URL")"
          PAYLOAD="$(echo "$IDTOKEN" | cut -d '.' -f2 | base64 -d 2>/dev/null)"
          echo "Decoded OIDC token payload:"
          echo "$PAYLOAD" | jq

      # Step 6: Authenticate with Vault and fetch secrets
      - name: Authenticate with Vault
        id: vault
        uses: hashicorp/vault-action@v3
        with:
          url: ${{ secrets.VAULT_ADDR }}
          method: jwt
          path: jwt
          role: gh-actions
          jwtGithubAudience: https://github.com/${{ github.repository_owner }}
          namespace: ${{ secrets.VAULT_NAMESPACE }}
          exportEnv: true
          secrets: |
            ci/data/artifactory url          | ARTIFACTORY_URL;
            ci/data/artifactory repo_docker  | DOCKER_REPO;
            ci/data/artifactory username     | ARTIFACTORY_USER;
            ci/data/artifactory password     | ARTIFACTORY_PASSWORD

      # Step 7: Log in to JFrog Docker registry using Vault secrets
      - name: Docker login to JFrog
        run: echo "$ARTIFACTORY_PASSWORD" | docker login "$ARTIFACTORY_URL" -u "$ARTIFACTORY_USER" --password-stdin

      # Step 8: Build Docker image from current source code
      - name: Build Docker image
        run: docker build -t "$IMAGE_NAME:ci" .

      # Step 9: Scan Docker image for vulnerabilities using Trivy
      - name: Scan image for vulnerabilities
        run: |
          curl -sSfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh
          trivy image "$IMAGE_NAME:ci"

      # Step 10: Tag and push Docker image to JFrog Artifactory
      - name: Tag & push image to JFrog
        run: |
          IMAGE_TAG="${ARTIFACTORY_URL}/${DOCKER_REPO}/${IMAGE_NAME}:$(git rev-parse --short HEAD)"
          docker tag "$IMAGE_NAME:ci" "$IMAGE_TAG"
          docker push "$IMAGE_TAG"

      # Step 11: Deploy the app to Azure Web App using publish profile
      - name: Deploy to Azure Web App
        uses: azure/webapps-deploy@v3
        with:
          app-name: ${{ secrets.AZURE_WEBAPP_NAME }}
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
          package: .

      # Step 12: Perform health check after deployment
      - name: Post-deployment health check
        run: curl -f $HEALTHCHECK_URL || exit 1
